[問題文](https://atcoder.jp/contests/abc127/tasks/abc127_c)

#いもす法
#部分累積和
#累積和

- 資料
  - いもす法
    - https://imoz.jp/algorithms/imos_method.html
    - https://note.com/kirimin_chan/n/n7663e3bb8a05
- 部分累積和
  - https://qiita.com/drken/items/56a6b68edef8fc605821
- 解答
- https://atcoder.jp/contests/abc127/submissions/13653589

## 問題文の把握

- N コのカードとM コのゲートがある
- i 番目のゲートを通るには、下記のカードを所持している必要がある
  - Li, Li+1,... Ri 番目のカードのうちどれかを持っている
  - ↑ex.3番目のゲートを通るには、L3カードをもつか、R3カードどちらかを持っている
- 1 枚で全てのゲートを通過できるカードは何枚ある？

- 制約
- 1 <= N,M <= 10^5
- 1 <= Li <= Ri <= N

```
N M
L1 R1
LM RM

=> L1 R1 は、M コあるゲートの解錠条件

case1
4 2
  1 3
2 4
=> 2

2 つのゲートがあり,4 枚のカードがある

1 つめのゲートは L1(1),R1(3) 
2 つめのゲートは L2(2),R2(4) 
1番目のカードは L1 とマッチするため、1つめのゲートを通れる。しかし、L2,R2 にマッチしないため2つめは通れない
2番目のカードは L1 +1 のため、1つめのゲートを通れる。また、L2,R2 どちらにもマッチするため2つめも通れる
3番目のカードは R1 = N のため、1つめのゲートを通れる。また、L2+1 のため2つめも通れる
4番目のカードは L1 +3 のため、1つめのゲートを通れない。また、R2 = N のため2つめは通れる

case2
10 3
3 6
5 7
6 9
=> 1 
6 だけが通過できる

case3
100 1
1 100


100000枚のカードがあり、ゲートはたったひとつ
1,2枚目のカードが N == L1, N == L1+1 でゲートを通れる
100000 枚目のカードがR1 とマッチしゲートを通れる
よって、解答は3
```

## ロジック
説明がわかりにくいが、つまり L == N or N+1,もしくは R == N のときにゲートを通れる  
この条件に合致するカード(数値)を求めるということ  

- N, M の値を受け取り
- M の数だけ L, R の値を受け取り
- カウント変数定義(default:0)
- i=1 to N のloop を回す
  - ゲート通過フラグ値変数を定義(default:true) 
  - さらに j=0 to M のloop
    - i の値が l[j] と同値か+1, もしくは r[j] と同値か
    - 条件を満たさないものがあればフラグ値をfalse にしてbreak
  - j ループ後のフラグ値を見て true なら カウント変数 increment
- 解答を出力


### inspection
... 上記のロジックで解答したが、AC できず。  
回答者のコードを見つつ、いもす法で解く方法について考えていく  

この問題は入力値に着目することで
「Li,Riの値が有効なIDカードの範囲を表している」 　
「いもす法を使うことで範囲を効率よく扱える」  
ということに気づけるかがキモとなる  

よって、まず入力値の性質について考えていく

- 入力制約についての考察

例えば、この問題は以下のような入力はあり得ない

```
constraints: 1 <= Li <= Ri <= N

5 2
2 1 => Li(2) > Ri(1) なのでおかしい
8 10 => Li > N, Ri > N なのでおかしい
```

よって、  
Li=2, Ri=4 => 2〜4番目のIDカードを持っている人はOK
Li=1, Ri=3 => 1〜3番目のIDカードを持っている人はOK

という意味になる  

この意味で、与えれるLi,Riの入力値は**ゲートを通過できるIDカードの範囲**を表していることになる  
全てのゲートを通過できるということは、各ゲートの通過範囲が全て重なっている範囲を求めるということに他ならない    

この範囲を効率よく求める方法として、次にいもす法を使用する

### いもす法

いもす法は、さまざまあるパターンの範囲の重なる範囲を効率よく求める algorithm  

- 手順
- 前提: <全体範囲: 1~N>, <範囲パターン: Mコ>
- 範囲を扱う配列 L を定義(長さは N+1 と1つだけ長くする)
- 配列に 1 or -1 の bit を立てて各範囲 M コを定義
- 配列の前から順番に累積和を計算していく (L[i+1] += L[i] を繰り返す)

＊1 のbit は、個別の **範囲に入ったこと** を示す値で、-1 は、個別の**範囲から出た**ことを示す
[いもす法による解法](https://imoz.jp/algorithms/imos_method.html)を見るとイメージしやすい

＊累積和の上限は理論上 M であるため、累積和 = M の array index が最上値(大体の問題における解答値)となる
＊長さは N+1 と1つだけ長くするするのは、終端ぎりぎりを扱えるようにするため

#### 具体例

今回の問題でいうと、下記のような感じ

```
4 2
1 3
2 4

[1 0 0 -1 0] <= 1~3の範囲
[0 1 0 0 -1] <= 2~4の範囲
     ↓
[1 1 0 -1 -1] * 1 = index[0] で扱う

↓ i+1 += i(累積和)をしていくと...
[1 2 2 1 0]
 1 2 3 4
=> i=2,3 = m なので解答は 2

10 3
3 6
5 7
6 9
[0 0 1 0 1 1 -1 -1 0 -1 0]
↓ 累積和計算
[0 0 1 1 2 3 -1 -1 0 -1 0]
 1 2 3 4 5 6  7  8 9 10
=> i=7 = m なので解答は 1

10 1
1 10
[1 0 0 0 0 0 0 0 0 0 -1]
↓ 累積和計算
[1 1 1 1 1 1 1 1 1 1 -1]
```

### code

```
	n := getNextInt(scanner)
	m := getNextInt(scanner)
	imos := make([]int, n+1)
	for i := 0; i < m; i++ {
		l := getNextInt(scanner) - 1
		r := getNextInt(scanner)
		imos[l]++ // L条件のゲート
		imos[r]-- // R条件のゲート
	}
	fmt.Println(imos)
	ans := 0
	for i := 0; i < n; i++ {
		imos[i+1] += imos[i]
		if imos[i] == m {
			fmt.Println(i + 1)
			ans++
		}
	}
	fmt.Fprintln(writer, ans)
```

### pseudo code

解答時間:12h

