[問題文](https://atcoder.jp/contests/abc074/tasks/abc074_b)

## 問題文の把握

- x, y で表させる平面がある
- 平面上には N コのボールがある
- i 番目のボールの位置は (xi, i) にある
- ボールを回収するためにタイプ A, B のロボットを N 台づつ作成
  - Aについて
    - (0, a) で起動すると、y=a の地点まで移動してボール回収&起動地点に戻る
    - 線上にない時は停止したまま
    - 各 A ロボットは(0, i) の地点に設置
  
  - B について
    - (K, b) で起動すると、y=b の地点まで移動してボール回収&起動地点に戻る
    - ない時は停止したまま
    - 各B は(K, i) に設置

=> N 本の直線 y=1, y=2, y=N の上にそれぞれ 1 コづつボールがあり、その戦場にA, B のロボットがいる状態

- 2 N 台のロボットでボール回収する時、ロボットの移動距離の総和の最小値を求めよ
- 1 <= N, K <= 100
- 0 < xi < K

```
N
K
x1 x2 xN

ex.
1
10
2
=> ボール1コに対しロボットが1台づつ
N = 1 なので、回収するボールは 1 個だけ
1 個目のボールの座標は (xi, i) => (2, 1)
1 台目のA の座標は (0, i) => (0, 1)
1 台目のB の座標は (K, i) => (10, 1)
 
上記座標をもとに、移動距離を計算
A で回収すると行き移動距離:2 + 帰りの移動:2 = 4
B で回収すると行き移動距離:8 + 帰りの移動:8 = 16
答え(出力)は 4

ex. 
2
9
3 6
=> ボール2コに対しロボットが2台づつ
N = 2 なので、回収するボールは 2 個
1 個目のボールの座標は (xi, i) => (3, 1)
1 台目のA の座標は (0, i) => (0, 1) => 移動距離: 4
1 台目のB の座標は (K, i) => (9, 1) => 移動距離: 12

2 個目のボールの座標は (xi, i) => (6, 2)
2 台目のA の座標は (0, i) => (0, 2) => 移動距離: 14
2 台目のB の座標は (K, i) => (9, 2) => 移動距離: 8

1コ目:4 + 2コ目:8 = 12
```

問題がやや複雑なので、かみ砕いて考える
ボールが N コ配置され、それぞれの座標は xi で示される  
よって、N の値に応じて xi の個数も変わる

ロボット A, B の違いは、配置される位置  
入力値 K に基づいて、B の方が x 座標で遠くに配置される  

## ロジック

重要とまるのが、ロボット A,B それぞれでボール回収のためのロジック  
例を見てみると、ボールの配置、A,B の配置座標は同じ y 軸にあることがわかる
 
- 10 コ目のボールを回収しにいくには、10 台目のロボットがいい  
- i コ目のボールの回収に最短のロボットは常に i 番目のロボットである
- ロボットがボールを回収しにいく時には x 軸(横軸)のみの移動である
- A の移動コストは常に入力値 xi * 2 
- xi < K という前提があるため、B の移動コストは常に入力値 (K - xi) * 2
ということがわかる  

上記前提に基づき、「N 回少ない方の移動距離を合算していき、総和を出力」する
### pseudo code


```
var n, k
var sum

for i to n
    var x = stdIn
    var aCost = x * 2
    var bCost = moveB(x, k)
    sum += aCost > bCost ? bCost : aCost
print(sum)

func Bmove(x, k) {
  // xi > K の前提に基づく
  return k - x * 2
}
```

### tips

time complexity は O(n)