[問題文]()

#dp
#漸化式
#yes/no

## 問題文の把握

- 制約　1 <= x <= 1000000

### dpを使う糸口

100円未満は,不可能。0円だけは可能
100円代は,100~105まで
200円代は,200~210まで
300円代は,300~315まで

- 直近の値を元に、次の値を計算できる
- 直近の値によって、次の値でとりうるレンジが決まる
=> dp問題でよく出るカエルの最短の道筋問題と同じ。
  一次元配列のdpが適用できる

dpの最大値について考えると、制約の1000000までやる方法もある。  
ただ、回答にあたっては入力値 X までのdpが作れてれば十分

### yes/no系DP
dpの中でも「この条件下でtrue/falseになりうる」を判定するdpをyes/no DPという
今回の問題はまさにYes/Noを答える問題  

dpの要素の型はtrue/falsenになり、**初期処理で特定の要素だけをtrue**にして、そこを起点に漸化式を作っていく  
今回で言うと、0円は硬貨0枚で実現でき、最小値である。よってdp[0] = trueとする

よって初期化処理は下記になる

```
var dp[X]bool
dp[0] = true
```

### 漸化式の作成

漸化式は数式の一つで**数列において前の項の結果から、現在の項の値を求める方法**のこと

繰り返すが、  
100円未満は,不可能。0円だけは可能  
100円代は,100~105まで  
200円代は,200~210まで  
300円代は,300~315まで  

315が可能であるためには、**2枚目まで105*2である**という前提が必要。
この部分をfor文を使った漸化式で表現する  

まず、100~105まで、のように下一桁の部分をtrueにするループを作成

```
for 0 to 6, i
  dp[i+100] = true  
```

漸化式では、前の項の値を元に現在の項の値を求める必要がある
100円のマスをtrueにするためには、0円のマスがtrueである必要があるということ

```
for 0 to 6, i
  if dp[i] 
    dp[i+100] = true  
```

これだと、x01円以降のマスがtrueにできない
`dp[210] == true` ならば.その値プラス100~105の範囲をtrueにしたい  

この`210`のindexを指す部分を、次のループで作る　　
`dp[j<210>+i<0~5>+100] = true`

配列要素数は、X以下にしてあるので、オーバーしないように注意する  

```
for 0 to 6, i
  for 0 to i+j+100 <=x,j // 0toXにするとi+j+100の合計値がXを超えるので注意。また、dp[x]まできっちり判定する(ここが回答になる値)
    if dp[j] 
    dp[i+j+100] = true   
```


