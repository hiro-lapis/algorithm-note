[問題文](https://atcoder.jp/contests/abc132/tasks/abc132_c)

## 問題文の把握

- N コの競プロ問題を作成し、それぞれには 1~N の難易度がついている
- 各問題難易度は di で表される
- ある整数 K を定義する。K 以上ならARC K 未満なら ABC の問題という風に二分する
- ARC/ABC 用の問題が同数になるような整数 K は何通りあるか

- 制約
- 2 <= N <= 10^5
- N は必ず偶数
- 1 <= di <= 10^5

```
N
d1 d2 ... dn

case1 
6
9 1 4 4 6 7
=> 2

case2
8
9 1 14 5 5 4 4 14
=> 0

case3
14
99592 10342 29105 78532 83018 11639 92015 77204 30914 21912 34519 80835 100000 1
=>42685
[7]77204 - [6]34519
```
## ロジック

問題を難易度順に並べて、2 つに分割する  
内容からしてbinary search が絡んでいそうな雰囲気  

ここで、case3 について考えてみる  
14 コの問題を並べ替えると、以下のようになる  
`[1 10342 11639 21912 29105 30914 34519 77204 78532 80835 83018 92015 99592 100000]`  

で、問題を 2等分する場合、`[6]34519` が中間となる
さらに、`[7]77204 - [6]34519` を計算すると、答えの 42685 となる!  

回答が 0 になる case2 で考えると、`[4]5 [5]5` となることがわかる  
よって、以下のような操作で解答を算出できる

- 配列を昇順にソート
- 二分探索の要領で中間値と、その次の値を抽出
- それぞれが同値なら 0 を出力
- それ以外は 次の値 - 中間値 の結果を出力

### pseudo code

```
var n
var list []int
list = stdIn

front = list[length/2] 
back = list[length/2+1]

if front == back
    print(0) 
else
    print(back - front) 
```

### tips

解くまでに 28 分, 1回で AC できた🙌  
time complexity は O(n)  
ソート処理以外は定数時間で処理が終わる  
