[問題文](https://atcoder.jp/contests/abc138/tasks/abc138_c)

## 問題文の把握

- 鍋と N 個の具材を持っている
- 各具材は実数で表される価値をもつ(1 <= i <= N)
  - i コ目の具材の価値はvi 
-  この具材を鍋に入れると、1つの具材になる。これを合成という 
  - 新たな具材の価値は `(x+y)/2`

- 合成を N-1 回行うと、最後に1個の具材が残る
- この時、ラスイチの具材が取りうる最大の価値を求めよ

- 制約
- 2 <= N <= 50
- 1 <= vi <= 1000

```
N
v1 v2 ...vn

2
3 4
=> 3.5 
(3 + 4) / 2 = 3.5

case2 
3
500 300 200
=> A : STEP1: (300 + 200) / 2 = 250 STEP2: (500 + 250) / 2 = 375
=> B : STEP1: (500 + 300) / 2 = 400 STEP2: (400 + 200) / 2 = 300
=> C : STEP1: (500 + 200) / 2 = 350 STEP2: (350 + 300) / 2 = 325

=> A の375

case3
5
138 138 138 138 138
=> 138
```
## ロジック

パッと見た感じ、考えうる方法は 2 つ

- ①動的計画法で、全部のパターンを効率よく計算して、一番高い組み合わせを探す方法 　
- ②高い組み合わせを作る方法の規則性を見出して、入力値を受け取ってすぐに最大値を計算する

```
3
1000 800 100

A: (1800) / 2 = 900 => (1000) / 2 => 500
B: (1100) / 2 = 550 => (1350) / 2 => 675
C: (900) / 2 = 450 => (1450) / 2 => 725

3 
400 10 30
A: 40 / 2 = 20 => 420 / 2 => 210 
B: 430 / 2 = 215 => 225 / 2 => 112.5 
B: 410 / 2 = 210 => 240 / 2 => 120 
```

case の例も含めて考えてみると、小さい値から合成していった方が最終的な点数が高くなる規則性がある  
よって、②の方法で解いていく

注意点として、価値は小数点以下がある場合は少数も、整数の場合は少数としての表記なしでの出力が求められる  
言語仕様によって違いはあるが、整数かどうかで cast して出力するのがいい  

Go においては、単純に int cast した値と ceil した値を同じ値か比較することでチェックすることができる
### pseudo code

```
var n
var list [n]int

sort list asc

var mix = list[i]
for i=1 to n
    mix = (mix + list[i]) / 2

print(mix)
```

### tips

- time complexity は O(n)  
