[問題文](https://atcoder.jp/contests/abc153/tasks/abc153_d)

## 問題文の把握

- ゲームでモンスターと戦っている
- モンスターの体力は H
- 1 ターンごとにモンスターを 1 体選んで攻撃。すると、以下の結果になる
  - モンスターの体力が X >1 の状態だと分裂する。すなわち、攻撃対象は消滅するが、体力 [X/2] のモンスターが 2 体現れる
  - モンスターの体力が 1 の状態で攻撃すると、体力は 0 になる
- 全てのモンスターの体力を 0 以下にすれば勝利
- モンスターに勝つまでに最小で何回攻撃が必要かを求めよ

- 制約
- 1 <= H <= 10^12

```
H

case1
2
=> 3
2 => 1,1 => 1 => 0 と、3回の攻撃で0になる

case2
4
=> 7
4 => 2,2 => 1,1,2, => 1,1,1,1 
  => 1,1,1,0 =? 1,1,0,0 => 1,0,0,0 => 0,0,0,0

in:5 => out:7

case3
1000000000000
=> 1099511627775
2^40 -1 :約1TB

6
=> 7
6 > 3,3 > 1,1,3 > 1,1,1,1 
  => 1,1,1,0 =? 1,1,0,0 => 1,0,0,0 => 0,0,0,0

7
=> 7
7 > 3,3 > 1,1,3 > 1,1,1,1 
  => 1,1,1,0 =? 1,1,0,0 => 1,0,0,0 => 0,0,0,0

8
=> 15  
8 > 4,4 > 2,2,4 > 2,2,2,2
  => 2 1 つ につき 3 回攻撃 を 4 回 = 12 
  
10 
10 > 5,5 > ...
=> 15

16
=> 31
16 > 8,8 
16を8に分割する攻撃1回 + 8 を消す15回*2
     

```

## ロジック

入力値が 3*10^5 以上のため、バッファを使った入出力は必須  
また、受け取った 10^12 の入力値を、提示されたロジックでまともに計算していたらとてもじゃないが計算が間に合わない   

そこで、提示された case を元に入力値/出力値に傾向がないか考えてみる

```
＊ X/2 でのあまりは切り捨て

in:1 => out:1
in:2 => out:3
in:3 => out:3
in:4 => out:7 
in:5 => out:7
in:6 => out:7 
in:7 => out:7 
in:8 => out:15
in:16 => out:15
in:32 => out:31
```
in:2 以外のケースを除き、
input が 2^n の値になる度に、2^n-1 の攻撃が必要になることがわかる

これをロジックにすれば良さそう  

### pseudo code

```
var h int64

answer = 0
count = 1
for h > 0
    answer += count
    h /= 2
    count *= 2
print(ans)
```

### tips

解答にかかった時間: 2h
不要に複雑なロジックを組んでしまった  
解答をみると、至って単純な理屈であることがわかる　　

また bit 演算を使って解凍している人もいるようだった  

### int32,int64

int32 は -2147483648 ～ 2147483647、約 21 億までの値を扱える
10^9 で10 億  

int64 は -9223372036854775808 ～ 9223372036854775807、約 922 京までの値を扱える
10^18 で100 京  

uint() で負数を扱わないことで、int の時の 2 倍の値を扱える

- 