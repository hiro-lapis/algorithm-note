[問題文](https://atcoder.jp/contests/abc323/tasks/abc323_d)

#bit演算


## 問題文の把握

- 入力値
- N : サイズ
- C : 各種スライムの匹数

- サイズNのスライムがC匹いる。
- 同じサイズのスライム2匹を合体させて倍のサイズのスライムにすることができる
- できるだけ数が最小になるよう合体をさせた場合の値を求めよ

- 制約
- 1 <= N <= 10^5
- 1 <= Si <= 10^9
- 1 <= C <= 10^9
- S1, S2, ... , SN は全て異なる
- 入力は全て整数


```
case1
3
3 3
5 1
6 1
=> 3

case2
3
1 1
2 1
3 1
=> 合体できる数が0なので、入力値で与えられた匹数のまま
```

## ロジック

・受け取る入力値はサイズの小さい順とは限らない  
よって、スライムのいる配列 S を1順しただけでは合体を全部できない  
・小さい方から合体させることによっては結果の匹数を一番減らせる
・入力値が大きく、実行時間を意識した計算が必要

以下、コードを元に解説していく


```	n := getNextInt(scanner)

	slimes := map[int]int{}
	for i := 0; i < n; i++ {
		s := getNextInt(scanner)
		c := getNextInt(scanner)
		// 1. 2で割り切れるまでビットをずらす
		// s&1で下一桁をビット値で参照できる
		for s&1 == 0 {
			s >>= 1
			c <<= 1
		}
		// 2. 最小サイズになった後の数を足し合わせる
		slimes[s] += c
	}

	ans := 0
	for _, v := range slimes {
        // 3. 下一桁が1になるまで合体を続け、1に回答値の数に加え、0になったら次のサイズのスライムに移る
		for v != 0 {
		    // 4. 下一桁が1になったら、それを回答値の数に加える
			if (v & 1) == 1 {
				ans++
			}
		    // 5. bitをズラす(1の時は0になる)
			v >>= 1
		}
	}
	fmt.Println(ans)
```

### 2で割るよりもビットをずらす方が早い

正の整数の場合、基本的に同じ結果になる。  
しかし、ビットをズラす方が利点がある

それぞれの処理内容は下記の通り  

- ビットの右シフト: n >>= 1 は、n のすべてのビットを右に1つシフトします。これにより、最下位ビットが捨てられ、最上位ビットには0が挿入される
- 2で割る: n /= 2 は、n を2で割る数学的な演算操作  

つまり、ビットをズラすという操作は計算処理というよりメモリの割り当てを変更する。それに対して算術演算子を使う操作は計算処理を行う。  
モダンなコンピュータのハードウェアは、ビットのシフト操作を非常に高速に行えます。したがって、ビットシフトが直接サポートされている場合、2での除算よりも右シフトの方が高速になることがある。

### tips

time complexity は O(n log n)
