[問題文]()

## 問題文の把握

- 長さ N の文字列 S がある
- 各文字は前から Si (1 <= i <= N) で表される
- 以下の操作を好きな順番で 0 回以上行うことができる
  - A円払い、S の左端(1文字目)を右端(N) に移動する
  - B円払い、1~N 以下の整数 i を選び、Si を好きな英小文字で置き換える
- 上記操作で回文を作る場合、最低何円必要か?

- 回文とは、`refer` のように前後から読んでも同じ読みになる文のこと

- 制約
- 1 <= N <= 5000
- 1 <= A,B <= 10^9
- S は英小文字 。文字数:N

```
N A B
S
case1
5 1 2
rrefa
=> 3

case2
8 1000000000 1000000000
bcdfcgaa
=> 4000000000!

```

## ロジック

case2 の出力の大きさに驚くが、1回あたりの操作に必要な円が大きいだけで、操作回数は多くない

回文であるための条件は、、、
- N = 奇数の時
  - 1文字を除いて各アルファベットが 2n 文字あること
  - 中央の文字以外が左右対象であること
- N = 偶数の時
  - 各アルファベットが 2n 文字あること
  - 全ての左右対象であること

2n 文字になるような調整は、B の操作で行って調整できる  
左右対称になるような調整は、A の操作になる  

わからないので、ロジックだけ考える

- for 文で、S の各文字の数を計算する
- A の操作ロジック判定
  - 偶数回登場する文字を探し出す
  - 偶数回出るうち、前方の文字のindex を取得
  - 後方文字のindex を取得
  - 回文にするために置き換えるべきindex を判定
  - 
- Bの操作ロジック実行
  - 奇数文字の中で、反対から読んでいった時に対になるindex も奇数文字である文字を B 操作で置き換え
  - rrefa なら、



```
bcdfcgaa
=> bcdfcgaa -> bcdfcgaa 
=> bcdfcgaa -> 
=> bcdfcgaa

```

### 解説

[ccppjsrb さんのコード](https://atcoder.jp/contests/abc286/submissions/38197170)を参考に考察する  

公式の解説にも書かれている通り、A の文字列配置替え =>B 文字置き換えの順に処理する全探索を実行する
A の操作は、左端と右端を入れ替える操作。N 回行うと元の状態に戻るため、N 回以上は行わないことがわかる

↓ざっくりしたイメージ  

```
var cost
for i to N (A operation)
  for B operation 
    cost += B ope cost
  cost += A ope cost
  
print(cost)
```

回答コードの構成も、概ね同じような構成になっている

### B loop detail

具体的に回答となるB loop コードが以下。
B の操作内容がパッと見理解できないので深堀していく  

```
  l := i
  r := i + n - 1
  sum := a * i
  fmt.Printf("l is %d : r is %d \n", l, r)
  for l < r {
      // ループ
      if s[l%n] != s[r%n] {
          fmt.Printf("  l[%d] is %v : r[%d] is %v \n", l%n, s[l%n], r%n, s[r%n])
          sum += b
      }
      l++
      r--
  }
  
======================
5 1 2
rrefa

l is 0 : r is 4 
  l[0] is 114 : r[4] is 97 
  l[1] is 114 : r[3] is 102 
0 回A 操作をした時の cost 4 
l is 1 : r is 5 
  l[2] is 101 : r[4] is 97 
1 回A 操作をした時の cost 3 
l is 2 : r is 6 
  l[2] is 101 : r[1] is 114 
  l[3] is 102 : r[0] is 114 
2 回A 操作をした時の cost 6 
l is 3 : r is 7 
  l[3] is 102 : r[2] is 101 
  l[4] is 97 : r[1] is 114 
3 回A 操作をした時の cost 7 
l is 4 : r is 8 
  l[4] is 97 : r[3] is 102 
  l[0] is 114 : r[2] is 101 
4 回A 操作をした時の cost 8 
3
```

ループごとに l,r の値がincrement, r の値を N で剰余算することで、後ろから i 文字を比較  
つまり、「前から i 文字目と後ろから i 文字目を比較。文字が異なる場合は B の操作を行ったものとしてcost を加算する」という操作を行っている  

操作内容の性質上、B 操作だけで回文を作ることが可能なため、  
i = 0 : A 操作 0 回　B 操作だけで回文を作成した時の cost sum   
i = 1 : A 操作 1 回した後に　B 操作で回文を作成した時の cost sum   
i = 2 : A 操作 2 回した後に　B 操作で回文を作成した時の cost sum  
というループ処理になっている

### A loop detail

```
	for i := 0; i < n; i++ {
		// l = 頭、r = 右から i 番目
		l := i
		r := i + n - 1
		sum := a * i
	// B loop
    ans = min(ans, sum)
==========
5 1 2
rrefa
l is 0 : r is 4 
  l[0] is 114 : r[4] is 97 
  l[1] is 114 : r[3] is 102 
0 回A 操作をした時の cost 4 
l is 1 : r is 5 
  l[1] is 114 : r[0] is 114 
  l[2] is 101 : r[4] is 97 
1 回A 操作をした時の cost 3 
l is 2 : r is 6 
  l[2] is 101 : r[1] is 114 
  l[3] is 102 : r[0] is 114 
2 回A 操作をした時の cost 6 
l is 3 : r is 7 
  l[3] is 102 : r[2] is 101 
  l[4] is 97 : r[1] is 114 
3 回A 操作をした時の cost 7 
l is 4 : r is 8 
  l[4] is 97 : r[3] is 102 
  l[0] is 114 : r[2] is 101 
4 回A 操作をした時の cost 8 
3

```

`sum := a*i` とすることで、i 回目のループでは i 回 A操作を行った時のcost を追加している
A 操作を i 回行うということは、B 操作で置き換える文字の配置も変わるということなので、l,r の値を調整している  

```
i = 1 reafe
=> A操作で 1文字目が左端に映るので、S[1] == S[0](初期値2文字目と初期値1文字目)を比較
  次いで、S[2] == S[4](初期値3文字目と初期値5文字目)を比較
  

i = 2
=> A操作で 1,2文字目が左端に映るので、S[2] == S[1](初期値3文字目と初期値2文字目)を比較
  次いで、S[3] == S[0](初期値4文字目と初期値1文字目)を比較

```

### pseudo code

```
```

### tips

#### 文字列の 1 文字だけを参照する方法 

string 変数を　`S[i]` のように参照すると,その1文字だけを参照できる  
出力は[ASCII table](https://www.rapidtables.com/code/text/ascii-table.html) になる  
data type は unit8 (0~255 符号なし整数。ASCII で使われる255 に収まる)  

```
test := "test"
print(test[0]) => 116 (uint8=116)
```

なお、文字列として出力したい時は `S[0:1]` のようにする必要がある  

#### 文字列の特定の箇所を循環参照するロジック

circular queue でもやったやり方

配列や文字列を, 配列要素数/文字数で剰余算すると、余りの値は常に要素数の範囲内に収まる  
この性質を利用して、`i + n - 1` で右から i 番目の要素を参照するロジックが組める   
