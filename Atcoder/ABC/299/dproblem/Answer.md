[問題文](https://atcoder.jp/contests/abc299/tasks/abc299_d)

#インタラクティブ
#binarysearch
#考察

## 問題文の把握

- ジャッジが 0/1のみからなる長さ N の文字列Sを持っている
    - S1 = 0,SN = 1 である
- 初期で受け取るのはSの長さ N のみ
- ジャッジに対して以下の質問を20回までできる
  - 1 <= i <= n のSi の値を尋ねる
- 質問をした上で、1 <= p <= N-1 かつ Sp ≠ Sp+1 を満たす整数pを出力せよ

- 制約
- 2 <= N <= 2 * 10^5

- 注意
- 出力の度に末尾改行を入れて出力をflush すること

```
case1
n
↓
out: ? 1
int : 0

out: ? 6
int : 1

out: ? 5
int : 0

out: ! 5
```

## ロジック

- 条件を満たす整数pは絶対存在する

S1=0, SN=1 のため、値の異なる2文字が絶対に存在 = 整数pの条件を満たしている文字が存在する

- 探索ロジック

前方から順々に20回値を探索していったのでは2 * 10^5 の範囲を探索できないため、探索の仕方を考える必要がある

探索といえば binary search, ということで、binary search を元にロジックを考える

```
l = S1, r = SN
middle = (l + r) / 2

s[middle] = 0 なら、S1=0 と値は異なる。
S1~middleの中間でpがある可能性はあるが、保証がないためl~middleを探索範囲から外す
↓
l = middle, r =SN
s[middle] = 0 なら、S1=0 と値は異なる。
S1~middleの中間でpがある可能性はあるが、保証がないためl~middleを探索範囲から外す


```



1 <= p <= N-1 かつ Sp ≠ Sp+1 を満たす整数pを出力
=> 連続する文字列のうち、前後の値が異なるindex のうち手前の値を出力する


### pseudo code


```
```

### tips

- `(l + r) >> 1` で 1bit ずらすことで高速で 1/2 できる
