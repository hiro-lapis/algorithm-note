[問題文](https://atcoder.jp/contests/abc285/tasks/abc285_b)

## 問題文の把握
- 長さ N の文字列 S を受け取る
- S の x 文字目は Sx で表される(1<=x<=N) 
- 各文字 i = 1,2...N-1 について、以下条件を満たす最大の正数 l を求める
  - l+i <= N
  - 1 <= k <= l を満たす整数 k で Sk ≠ Sk+1 である
- l=0 は条件を常に満たす

- 2 <= N <= 5000
- S は英字小文字
- N -1 行に渡って出力

``` 
入力
6
abcbac

出力
5
1
2
0
1
```

- 文字同士を比較する
- ループ回数は N -1

## ロジック
問題文の読解から注意して取り組む必要がある

出力例をよく見てみると、
- 各ループで左側の比較文字は常にS1 から開始し、S2,S3 とincrement される
- 各ループで右側の比較文字は、ループ毎にindexの間隔が広くなっていく
- i = 1 で、1つも致する文字がない場合は l = N - i の値 5 である
- i = 2 の時、
  - N = l + i => 6 = l + 2 => l = 4. l が 4 の時に 1 と出力されている  
  - S1 ≠ S3、S2 = S4 となっている。問題文の Sk ≠ Sk+1 を満たすのは S1 ≠ S3 なので、k = 3
  - l の初期値が 4 で、Sk の 3 の値とで差し引き 1 になる

などがわかる。
ループは 2 つ作成する
- A: ある文字とある文字を比較するループ 
- B: 比較する文字の間隔を increment する

なお、5 文字の文字列の4 文字目と 7 文字目を比較するような処理が走らないよう、A ループ に break 条件を忘れないようにする 

### pseudo code


```
var n, s

for i to n
    var l = 0
    for j to n
        // 文字数範囲外の参照でないよう判定
        if i + j >= n {
            break
        }
        front := s[j : j+1]
        back := s[j+i : j+i+1]
        if front == back {
            break
        }
        l++
    print(l)
```

### tips

time complexity は O(n-1 + n) => O(n) となる
go について、 
- string[i:j] で i~j 文字目までの文字を切り出し
- i, j をなくすことで ~ 文字目以降/文字まで という切り出しも可能
- 日本語などのUTF-8文字は 1 文字 3 byte なので、以下のようにする必要がある
  - 文字数出力: `utf8.RuneCountInString(str)`
  - 文字数切り出し: `string([]rune(str)[:2])`
  

