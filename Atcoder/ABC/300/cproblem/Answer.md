[問題文](https://atcoder.jp/contests/abc300/tasks/abc300_c)
[解説](https://youtu.be/P7CL5TfLqCM)

#文字列操作
#配列と文字のマッピング
#考察

## 問題文の把握

- H * W マスの `.` `#` からなる二次元配列がある
- マス目の中には x の字を作る形で # が配置されている
- x の字の大きさによってサイズ1、サイズ2... とサイズが大きいものとして扱う。
- 最小のサイズ1のxは S1 と表記する
- 与えられるマス目と文字の中にある各種サイズの x の数をカウントせよ

- 制約
- `#` は常にどこかしらの x を形成する一部分となっている
- x 同士は隣接しない。常に 1 マス以上離れている

```
case1
5 9
#.#.#...#
.#...#.#.
#.#...#..
.....#.#.
....#...#
=> 1 1 0 0 0

case2
3 3
...
...
...
=> 0 0 0

case3
3 16
#.#.....#.#..#.#
.#.......#....#.
#.#.....#.#..#.#
=> 3 0 0

case4
15 20
#.#..#.............#
.#....#....#.#....#.
#.#....#....#....#..
........#..#.#..#...
#.....#..#.....#....
.#...#....#...#..#.#
..#.#......#.#....#.
...#........#....#.#
..#.#......#.#......
.#...#....#...#.....
#.....#..#.....#....
........#.......#...
#.#....#....#.#..#..
.#....#......#....#.
#.#..#......#.#....#
=> 5 0 1 0 0 0 1 0 0 0 0 0 0 0 0
```

## ロジック

- Sn の n (サイズの理論上最大値)は、min(H,W) である

- x 印の上端マス数間隔は常に奇数である。すなわち、1,3,5,,,マス間隔である。2マス空くごとに size が1 アップする

- 入力値は常に正常な x を形作る値という前提が与えられている
よって、受け取ったCの配列情報を上から探索して行って、x の上端を間隔をカウントするだけで x のサイズをカウントすることができる

```
5 9
#.#.#...#
.#...#.#.
#.#...#..
.....#.#.
....#...#
```

↑のような値を受け取った場合、
1つめの x が 0(1マスめ),2つめの x が2にでているため、2*2 のxである(size 1) 
3つめの x が index4(5マスめ),4つめの x がindex=8にでているため、2*2 のxである(size 2)

が、この考え方では解答できず。
x の上側の間隔を計算するだけだと、case4 のような x の間にxが入っているケースでのロジックが複雑になる
また、サイズ5 の x を見つけた後は必然的に次の行でサイズ4の x を見つけることになる
一度見つけた S の構成部分となる # は判定に入れないようにするにはどうすればいいかを考えるのが難しい。。。

よってこのアプローチはヨロシクない。解答を見て得た下記のロジックを利用する  

#### S を求めるロジック

問題のキモは、どうやって x の判定を行うか？ということ  
`#` が与えられる中で、最も大きい x を構成するよう判定を行い、一度判定したxは判定しないようにしたい  

そこで、下記のように考えてみる
1. x の文字の中でも、中心になるxかを判定
2. 中心だった時、サイズを計算する

```
[タテ: i, ヨコ: j]
x.x
.x. <= (i, j)の文字が x  & 各左右斜めのマスも x である時、Sに該当する  
x.x

x のサイズが大きくなるごとにチェックするマスのindexも更新される

左上: (i-1, j-1), (i-2, j-2) ... 
右上: (i-1, j+1), (i-2, j+2) ... 
左下: (i+1, j-1), (i+2, j-2) ... 
右下: (i+1, j+1), (i+2, j+2) ... 
```

### pseudo code

```
H, W = stdIn
ll = [][]str
s = [] length of min(H, W)
 
for i=0 to H
    for j=0 to W
        ll[i][j] = stdIn

for i=0 to H-1
    for j=0 to W-1
        if ll[i][j] == '#'
            size = check(ll)
            if size > 0,  s[count of size]++

print(s)

func check(ll)
    var size int
    var range = 1
    for i=1 to H-1, j=1 to W-1 
        if '#' == range lu(left up),  ru(right up), ld(left down), rd(right down)
            size++
            range++
            increment each index of adjacent slice
        else 
            break
    return size
```

### 別解

もうひとつの解法として、 マスの数をカウントする方法がある

・`#` があったら隣接するマスの `#` へ移動
・・移動回数をカウント
・・移動した場所は探索済にする
・・後続の処理で再度探索してしまわないよう、探索済かどうかの判定も行う
・探索が終わったら、移動回数を /4 すると、サイズが求められる

探索方法はなんでもいい。DFS, BFS でも


### tips

- time complexity は O(H*W * (H*W /4)) amortize して O(HW)
- 