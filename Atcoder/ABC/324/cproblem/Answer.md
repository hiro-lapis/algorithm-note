[問題文](https://atcoder.jp/contests/abc324/submissions/46589559)

#文字列

## 問題文の把握
問題の意味が少しややこしい。送りたかった文字列Tはわからないままである。
しかし、入力SnがTとなりうるどうかを判定せよ、と書いてある通り、T は実質 Snの文字列である。
よって、行うべきはSnとTの文字列比較である。

## ロジック

ある問題文で提示されている4つの条件それぞれをコードで再現し、愚直に処理していく

- T`はTと等しい

```
Si == T
```

- T′は、Tのいずれか1つの位置（先頭と末尾も含む）に英小文字を 1 つ挿入して得られる文字列である。
- T′は、T からある1文字を削除して得られる文字列である。

挿入削除と書いてあるが、実際にそういった処理をする必要はない  

挿入してマッチするということは、挿入前のSiの文字数がT-1ということ。  
削除してマッチするということは、削除前のSiの文字数がT+1ということ。

また、挿入する1文字以外はマッチするということ。
途中の文字が異なる場合を考慮した走査は下記のようなロジックになる


```
// Tに対してInsert(1文字プラス)を想定したチェック
count = len(T)
// 左から右へ走査
for 0 to len(T)
    if Si[i] == T[i]
      count--
    else 
      l = i
      
// 右から左へ走査(左から走査した時の終端まで)
// Tに対して文字数が1文字加えるためSiのindexが1多い状態でチェック
for len(T)-1 to l && Si[j+1] == T[j]
      count--

return count == 0 // カウントが0になってないなら1文字挿入・削除してもマッチしない
```

また、Tに対して1文字挿入して文字がマッチする場合、  
それはSiに対して1文字削除する操作してマッチすること同義である。
↑のロジックに渡す引数の順序を入れ替えてあげることでこれが可能になる。


- T′ は、 T のある 1 文字を別の英小文字に変更して得られる文字列である。

変更なので、文字数は同じである必要がある。  
よって、左右から文字を走査していって、異なる文字数をカウント。
カウントが1文字だったら条件に合致する  

```
for 0 to len(T)
    if Si[i] != T[i]
      count++
      break

for len(T)-1 to 0
    if Si[i] != T[i]
      count++
      break

return count == 1
```
