# Sieve of Eratosthenes(エラトステネスの篩)

素数判定や素数列挙に使われる    
ある数 n が素数かどうかを判定するには、n^1/2(2分の1乗)より低い整数で n を割り切れるかどうかを判定すればいい、という点に着目している 　

-  n^1/2(2分の1乗) とは

- 二乗すると n になる数。つまり √n である  
4 ^1/2 は 2 である  
つまり、  
- 4 が素数かどうかを判定するには、2 以下の整数で剰余算して素数であるかを判定すればいい
- 29 が素数かどうかを判定するには、5 以下の整数(29 のルートは 5~6 の間である)で剰余算して素数であるかを判定すればいい

効率的に素数判定の篩(ふるい)にかけていく様子から、この名前がついている  

## time complexity: O(n log(n))
素数判定に使われる数の割合は、n の値が大きくなればなるほど小さくなる 　
この点で計算量は対数時間 O(n log(n)) になる

## implementation

```
var n

var isPrime = true
for i to (i^2) > n
    if n % i 
        isPrime = false
        break

return isPrime
```

### detail ~integral~

エラトステネスのふるいは、積分(integral)の原理を利用して実装されている  

積分とは、関数によって求められる`値の範囲`を求める計算のこと
関数f(x) の a から b までの値を積分するという感じで表現される  

エラトステネスは 2 から N までの数値での素数を列挙する関数だが、
この時の 「2 から N」 が 「a から b」 までに対応している  

また、2 から N までの数値を数え上げ、素数を 1 つ見つけるまでの計算量がグラフにおける Y 軸となる  
エラトステネスは後の計算になればなるほど次の素数を見つけるまでの計算回数が減る(先に見つけた素数によって素数でない数値の判定が省略される)ため、グラフの X 軸が進ほど Y 軸の面積は低くなる  
これを数式で表すと、
`N/1 + N/2 + N/3 + N/4 + N/5 ... + N/N` となる


### reference

[エラトステネスの篩](https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9)
[Golang : Sieve of Eratosthenes algorithm](https://www.socketloop.com/tutorials/golang-sieve-of-eratosthenes-algorithm)
