# Sieve of Eratosthenes(エラトステネスの篩)

素数判定(数値 n が素数であるか？)や素数列挙(1~nの範囲で素数を挙げる)に使われる  

・n^1/2(2分の1乗)の篩

ある数 N が素数かどうかを判定するには、2~N-1 までの範囲の数値で割り算をして、割り切れるかどうかを試す必要がある  

普通に計算するなら N = 101 の時に2~100 の範囲で100回試すことになる  
しかし、エラトステネスの篩により、2~10 の範囲のみ試せばよいことがわかっている  

例えば、3 の二乗は 9 である。これを逆にいうと、9 の1/2乗は 3 である
ある数 n が素数でない場合、割り切れる数は、n^1/2(2分の1乗)の範囲に必ず存在する  

つまり、  
- 4 が素数かどうかを判定するには、2 以下の整数で剰余算して素数であるかを判定すればいい
- 29 が素数かどうかを判定するには、5 以下の整数(29 のルートは 5~6 の間である)で剰余算して素数であるかを判定すればいい

・2の倍数の篩
ある数が素数と分かった場合、その数の2倍の数は素数ではない(2で割れるから)  
よって、2以上の偶数は、絶対に素数ではないことが確定する  

1~100 までの素数を列挙したり判定する時も、
- 3 が素数と分かった =>  6,12,24,72 は素数でない(篩から落とされる)
ということが確定する。これをメモ化していくことで効率よく素数列挙ができたりする  

効率的に素数判定の篩(ふるい)にかけていく様子から、この名前がついている

## time complexity: O(n log(n))
素数判定に使われる数の割合は、n の値が大きくなればなるほど小さくなる 　
この点で計算量は対数時間 O(n log(n)) になる

## implementation

```
var n

var isPrime = true
for i to (i^2) > n
    if n % i 
        isPrime = false
        break

return isPrime
```

### detail ~integral~

エラトステネスのふるいは、積分(integral)の原理を利用して実装されている  

積分とは、関数によって求められる`値の範囲`を求める計算のこと
関数f(x) の a から b までの値を積分するという感じで表現される  

エラトステネスは 2 から N までの数値での素数を列挙する関数
例えば、N = 10 の時は、2~10までの素数 `2,3,5,7` を出力するようになっている 
この時の 「2 から N」 が 「a から b」 までに対応している  

また、2 から N までの数値を数え上げ、素数を 1 つ見つけるまでの計算量が2次元グラフにおける Y 軸となる  
エラトステネスは後の計算になればなるほど次の素数を見つけるまでの計算回数が減る(先に見つけた素数によって素数でない数値の判定が省略される。メモ化を使った効率化)ため、
グラフの X 軸が進むほど Y 軸の面積は低くなる  
これを数式で表すと、
`N/1 + N/2 + N/3 + N/4 + N/5 ... + N/N` となる



### reference

[エラトステネスの篩](https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9)
[Golang : Sieve of Eratosthenes algorithm](https://www.socketloop.com/tutorials/golang-sieve-of-eratosthenes-algorithm)
