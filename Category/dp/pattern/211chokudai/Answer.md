[問題文](https://atcoder.jp/contests/abc211/tasks/abc211_c)

https://www.youtube.com/watch?v=Zu9S_kJ-7tk&ab_channel=AtCoderLive

#DP
#動的計画法
#文字列の組み合わせ
#漸化式

## 問題文の把握

- 文字列Sが与えられる
- 8文字を抽出しアンダーラインをひき、その文字が `c`, `h`, `o`, `k`, `u`, `d`, `a`, `i` となる組み合わせを求めよ
- 回答が大きくなる可能性があるので(10^9 +7)で割った値を出力せよ
制約

- 8 <= N <= 10^5

```
chchokudai
=> 3

chokudaichokudaichokudai
=> 45

```

## ロジック

ある文字列から特定のワードの出現回数を求める場合、愚直にやっていくと

探すワードが2文字の場合
=> N(N-1)/2。5文字から選んで、4文字から選ぶ。前後区別があるので2で割る
5文字の文字から探すなら,10通りのパターンから探す

探すワードが3文字の場合
=> N(N-1)(N-2)/2。5文字の文字から探すなら,30通りのパターンから探す

これを一般化すると、O(N^N)となる。  
探す文字列の長さNに依存して計算量が増える　　

今回の問題でいえば、8文字の単語の出現回数を探す。**O(N^8)**  
製薬によると与えられる文字の長さは最大 10^5 なので、10^13になり、愚直な処理はまったく間に合わないことがわかる。

### DPを使って問題をとく。漸化式も使う

DPを使うと、問題を小さい問題に分割して解くことができ、それが大きな問題を効率よくための手段になる。  


```
以下のように探索対象文字NxキーワードS文字の表を作成
最終的にabcという単語の出現回数を求める
    abcababc => N
a  |
ab |
abc|
↓
S    

a行では、aのみの出現回数をカウント
    abcababc => 
a  |11122333
ab |
abc|
↓
S    

【重要】ab行では、abの出現回数をカウント
*のポイントに注目。abの出現回数は、aの出現回数とbの出現回数の和になる
*の左上のマスを見ると、aの出現回数は2回。現在いるマスの左を見ると、bの出現回数は1回なので、1+2でabの組み合わせパターン数は3回になる
        *
    abcababc
a  |11122333
ab |01113
abc|

同じように次のabの出現も求める。
*の左上のマスを見ると、aの出現回数は3回。bの出現回数は3回なので、3+3でabの組み合わせパターン数は6回になる
          *
    abcababc
a  |11122333
ab |01113366
abc|

最後に、abcの出現回数を求める。
最初にabcが出現した時も、現在いるマスの右上と左の値を足すことで、その時点のabcのパターン数を求めることができる
    abcababc
a  |11122333
ab |01113366
abc|001

最後のマスでも同じように、abcの左・右上マスの値を足すことでパターン数を
           *
    abcababc
a  |11122333
ab |01113366
abc|00111117
```

### 漸化式
上記のやり方の中で、今までの値を使って次の値を求める方法があった。この方法を**漸化式**という。  
なお、漸という文字には、徐々に、次第に、という意味がある。

```
// 以下の漸化式が成り立つ

Si≠Tjのとき(文字列がヒットしない時)
    dp[i][j] = dp[i-1][j] // 1つ前の文字列の値を引き継ぐ
Si=Tjのとき(文字列がヒットする時)
    dp[i][j] = dp[i-1][j] + dp[i-1][j-1] // 1つ前のマスの値と、1つ前のマスの上の値を足す
```

なお、実際に実装する際には、**縦:キーワード、横:参照文字** になることもある。   
その際は漸化式で参照するマスが変わるので注意(実装コード参照)。
＊1つ前の文字数の文字列の処理


### pseudo code


```
```

### tips

